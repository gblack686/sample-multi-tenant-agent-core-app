# TAC Experts Plugin — Master Justfile
# Tactical Agentic Coding (TAC) methodology for agent-first development
#
# Usage: just <recipe>         Run a recipe
#        just --list           List all recipes
#        just --list <group>   List recipes in a group
#
# TAC Layer Reference:
#   Layer 1 — Command (Logic)         /experts:tac:plan "task"
#   Layer 2 — Agent (Isolation)       "Use @hooks-expert-agent to..."
#   Layer 3 — Orchestrator (Pipeline) /experts:tac:plan_build_improve "feature"
#   Layer 4 — Just (Reusability)      just plan-build-improve "feature"

# ─── Configuration ──────────────────────────────────────────
# Override these for your project

plugin_dir    := justfile_directory()
project_dir   := env_var_or_default("TAC_PROJECT_DIR", ".")
experts_dir   := project_dir / ".claude/commands/experts"
commands_dir  := project_dir / ".claude/commands"
agents_dir    := project_dir / ".claude/agents"
specs_dir     := project_dir / ".claude/specs"
model         := env_var_or_default("TAC_MODEL", "opus")
date          := `date +%Y-%m-%dT%H:%M:%S 2>/dev/null || echo "2026-01-01T00:00:00"`
ts            := `date +%Y%m%d-%H%M%S 2>/dev/null || echo "00000000-000000"`

# List available commands
default:
    @just --list

# ═══════════════════════════════════════════════════════════
# SETUP & INSTALLATION
# ═══════════════════════════════════════════════════════════

# Install TAC expert into a project (copies commands/experts/tac/)
install target_project=project_dir:
    #!/usr/bin/env bash
    set -euo pipefail
    target="{{target_project}}/.claude/commands/experts/tac"
    mkdir -p "$target"
    cp -r "{{plugin_dir}}/commands/experts/tac/"* "$target/"
    echo "TAC expert installed to $target"
    echo "Commands available:"
    echo "  /experts:tac:question"
    echo "  /experts:tac:plan"
    echo "  /experts:tac:plan_build_improve"
    echo "  /experts:tac:self-improve"
    echo "  /experts:tac:maintenance"

# Install a CLAUDE.md template — interactive selection
install-claude-md target_project=project_dir:
    #!/usr/bin/env bash
    set -euo pipefail
    echo "Choose a CLAUDE.md template:"
    echo "  1) option-a-enterprise       — Identity-first, formal teams"
    echo "  2) option-b-mission-control  — Domain-first, regulated projects"
    echo "  3) option-c-fullstack-blueprint — Composable, multi-stack (recommended)"
    read -p "Selection [1-3]: " choice
    case "$choice" in
        1) src="option-a-enterprise.md" ;;
        2) src="option-b-mission-control.md" ;;
        3|"") src="option-c-fullstack-blueprint.md" ;;
        *) echo "Invalid selection"; exit 1 ;;
    esac
    if [ -f "{{target_project}}/CLAUDE.md" ]; then
        echo "CLAUDE.md already exists. Backing up to CLAUDE.md.bak"
        cp "{{target_project}}/CLAUDE.md" "{{target_project}}/CLAUDE.md.bak"
    fi
    cp "{{plugin_dir}}/templates/claude-md/$src" "{{target_project}}/CLAUDE.md"
    echo "Installed $src as CLAUDE.md"
    echo "Edit it to match your project."

# Full project bootstrap — TAC expert + CLAUDE.md + directory structure
bootstrap target_project=project_dir:
    #!/usr/bin/env bash
    set -euo pipefail
    echo "=== TAC Bootstrap ==="
    echo ""
    # Create directory structure
    mkdir -p "{{target_project}}/.claude/commands/experts"
    mkdir -p "{{target_project}}/.claude/agents"
    mkdir -p "{{target_project}}/.claude/specs"
    mkdir -p "{{target_project}}/.claude/context"
    echo "[1/3] Directory structure created"
    # Install TAC expert
    just install "{{target_project}}"
    echo "[2/3] TAC expert installed"
    # Install CLAUDE.md
    just install-claude-md "{{target_project}}"
    echo "[3/3] CLAUDE.md installed"
    echo ""
    echo "Bootstrap complete. Next steps:"
    echo "  1. Edit CLAUDE.md to match your project"
    echo "  2. Run: just scaffold-expert my-domain 'My Domain' 'What it covers'"
    echo "  3. Run: just maintenance --all"

# ═══════════════════════════════════════════════════════════
# PROGRESSIVE EXECUTION MODES (Install & Maintain)
# "The script is the source of truth. Agents provide supervision."
# ═══════════════════════════════════════════════════════════

# ─── Install (3 modes) ──────────────────────────────────

# Deterministic install — hook only (CI/CD friendly)
init:
    claude --model {{model}} --dangerously-skip-permissions --init

# Deterministic install — hook only, no session (fastest)
init-only:
    claude --model {{model}} --dangerously-skip-permissions --init-only

# Agentic install — hook + prompt reads log + reports
init-agentic:
    claude --model {{model}} --dangerously-skip-permissions --init "/install"

# Interactive install — hook + questions + adapts (onboarding)
init-interactive:
    claude --model {{model}} --dangerously-skip-permissions --init "/install true"

# ─── Maintenance (2 modes) ──────────────────────────────

# Deterministic maintenance — hook only (CI/CD friendly)
maintain:
    claude --model {{model}} --dangerously-skip-permissions --maintenance

# Agentic maintenance — hook + prompt analyzes log + trends
maintain-agentic:
    claude --model {{model}} --dangerously-skip-permissions --maintenance "/maintenance"

# ─── Dev Servers ────────────────────────────────────────

# Run backend dev server (FastAPI + uvicorn)
backend *args:
    cd apps/backend && uv sync && uv run uvicorn main:app --reload --host 0.0.0.0 --port 8000 {{args}}

# Run frontend dev server (Vite)
frontend *args:
    cd apps/frontend && npm install && npm run dev {{args}}

# Run both backend and frontend (background backend, foreground frontend)
dev:
    #!/usr/bin/env bash
    echo "Starting backend on :8000..."
    (cd apps/backend && uv sync && uv run uvicorn main:app --reload --host 0.0.0.0 --port 8000) &
    BACKEND_PID=$!
    echo "Starting frontend on :5173..."
    cd apps/frontend && npm install && npm run dev
    kill $BACKEND_PID 2>/dev/null

# ─── Reset (clean state for testing) ───────────────────

# Remove all generated artifacts — clean install test
reset:
    #!/usr/bin/env bash
    set -euo pipefail
    echo "Resetting to clean state..."
    rm -rf apps/backend/.venv 2>/dev/null || true
    rm -rf apps/frontend/node_modules 2>/dev/null || true
    rm -f apps/backend/starter.db 2>/dev/null || true
    rm -f setup.init.log setup.maintenance.log session_start.log 2>/dev/null || true
    rm -rf app_docs/ 2>/dev/null || true
    echo "Clean state. Run: just init"

# Reset and reinstall (deterministic)
fresh:
    just reset
    just init

# Reset and reinstall (interactive — onboarding flow)
fresh-interactive:
    just reset
    just init-interactive

# ═══════════════════════════════════════════════════════════
# EXPERT SCAFFOLDING (TAC #3: Template Engineering)
# ═══════════════════════════════════════════════════════════

# Scaffold a new domain expert from templates
scaffold-expert domain domain_title description:
    #!/usr/bin/env bash
    set -euo pipefail
    target="{{experts_dir}}/{{domain}}"
    if [ -d "$target" ]; then
        echo "Expert '{{domain}}' already exists at $target"
        exit 1
    fi
    mkdir -p "$target"
    for file in "{{plugin_dir}}/templates/expert/"*; do
        filename=$(basename "$file")
        sed -e 's/{{{{DOMAIN}}}}/{{domain}}/g' \
            -e 's/{{{{DOMAIN_TITLE}}}}/{{domain_title}}/g' \
            -e 's/{{{{DESCRIPTION}}}}/{{description}}/g' \
            -e 's/{{{{DATE}}}}/{{date}}/g' \
            -e 's/{{{{AREA_1}}}}/Area 1/g' \
            -e 's/{{{{AREA_1_DESC}}}}/Description of area 1/g' \
            -e 's/{{{{AREA_2}}}}/Area 2/g' \
            -e 's/{{{{AREA_2_DESC}}}}/Description of area 2/g' \
            -e 's/{{{{AREA_3}}}}/Area 3/g' \
            -e 's/{{{{AREA_3_DESC}}}}/Description of area 3/g' \
            "$file" > "$target/$filename"
    done
    echo "Expert '{{domain}}' scaffolded at $target"
    echo "Files created:"
    ls -1 "$target/"
    echo ""
    echo "Next steps:"
    echo "  1. Edit $target/_index.md — fill in domain scope areas"
    echo "  2. Edit $target/expertise.md — seed with initial knowledge"
    echo "  3. Run: just self-improve {{domain}}"
    echo "  4. Try: /experts:{{domain}}:question 'How does X work?'"

# Scaffold multiple experts at once (space-separated: "domain1:Title1 domain2:Title2")
scaffold-experts *specs:
    #!/usr/bin/env bash
    set -euo pipefail
    for spec in {{specs}}; do
        domain=$(echo "$spec" | cut -d: -f1)
        title=$(echo "$spec" | cut -d: -f2-)
        echo "--- Scaffolding $domain ---"
        just scaffold-expert "$domain" "$title" "$title expert"
        echo ""
    done

# List all domain experts in the project
list-experts:
    #!/usr/bin/env bash
    set -euo pipefail
    echo "Domain Experts:"
    echo "═══════════════"
    if [ -d "{{experts_dir}}" ]; then
        for dir in "{{experts_dir}}"/*/; do
            domain=$(basename "$dir")
            files=$(ls -1 "$dir" 2>/dev/null | wc -l | tr -d ' ')
            has_expertise="no"
            [ -f "$dir/expertise.md" ] && has_expertise="yes"
            printf "  %-20s  %s files  expertise: %s\n" "$domain" "$files" "$has_expertise"
        done
    else
        echo "  No experts directory found at {{experts_dir}}"
    fi

# Validate expert structure — check all 7 standard files exist
validate-expert domain:
    #!/usr/bin/env bash
    set -euo pipefail
    target="{{experts_dir}}/{{domain}}"
    echo "Validating expert: {{domain}}"
    echo "═══════════════════════════════"
    standard_files=("_index.md" "expertise.md" "question.md" "plan.md" "plan_build_improve.md" "self-improve.md" "maintenance.md")
    all_ok=true
    for file in "${standard_files[@]}"; do
        if [ -f "$target/$file" ]; then
            lines=$(wc -l < "$target/$file" | tr -d ' ')
            printf "  %-25s  %4s lines\n" "$file" "$lines"
        else
            printf "  %-25s  MISSING\n" "$file"
            all_ok=false
        fi
    done
    # Check for extra domain-specific files
    extras=$(ls -1 "$target/" | grep -v -F -f <(printf '%s\n' "${standard_files[@]}") 2>/dev/null || true)
    if [ -n "$extras" ]; then
        echo ""
        echo "Extensions:"
        echo "$extras" | while read f; do
            lines=$(wc -l < "$target/$f" | tr -d ' ')
            printf "  %-25s  %4s lines  (custom)\n" "$f" "$lines"
        done
    fi
    echo ""
    if $all_ok; then
        echo "Result: PASS — all 7 standard files present"
    else
        echo "Result: FAIL — missing required files"
        exit 1
    fi

# Validate ALL experts in the project
validate-all-experts:
    #!/usr/bin/env bash
    set -euo pipefail
    pass=0
    fail=0
    if [ -d "{{experts_dir}}" ]; then
        for dir in "{{experts_dir}}"/*/; do
            domain=$(basename "$dir")
            if just validate-expert "$domain" > /dev/null 2>&1; then
                printf "  %-20s  PASS\n" "$domain"
                pass=$((pass + 1))
            else
                printf "  %-20s  FAIL\n" "$domain"
                fail=$((fail + 1))
            fi
        done
    fi
    echo ""
    echo "Results: $pass passed, $fail failed"
    [ "$fail" -eq 0 ] || exit 1

# ═══════════════════════════════════════════════════════════
# TAC EXPERT COMMANDS (via Claude CLI)
# ═══════════════════════════════════════════════════════════

# Ask a TAC methodology question (read-only, no changes)
tac-question question:
    claude --model {{model}} "/experts:tac:question {{question}}"

# Plan an implementation using TAC principles
tac-plan prompt:
    claude --model {{model}} "/experts:tac:plan {{prompt}}"

# Full ACT-LEARN-REUSE workflow — plan, build, self-improve
tac-pbi prompt:
    claude --model {{model}} "/experts:tac:plan_build_improve {{prompt}}"

# Run TAC self-improve against a source (loot.md, README, repo)
tac-self-improve source="":
    claude --model {{model}} "/experts:tac:self-improve {{source}}"

# Run TAC maintenance check
tac-maintenance *flags:
    claude --model {{model}} "/experts:tac:maintenance {{flags}}"

# ═══════════════════════════════════════════════════════════
# DOMAIN EXPERT COMMANDS (generic — works with any expert)
# ═══════════════════════════════════════════════════════════

# Ask a domain expert a question
question domain prompt:
    claude --model {{model}} "/experts:{{domain}}:question {{prompt}}"

# Plan with a domain expert
plan domain prompt:
    claude --model {{model}} "/experts:{{domain}}:plan {{prompt}}"

# Full plan-build-improve cycle with a domain expert
plan-build-improve domain prompt:
    claude --model {{model}} "/experts:{{domain}}:plan_build_improve {{prompt}}"

# Self-improve a domain expert's knowledge
self-improve domain source="":
    claude --model {{model}} "/experts:{{domain}}:self-improve {{source}}"

# Run maintenance on a domain expert
maintenance domain *flags:
    claude --model {{model}} "/experts:{{domain}}:maintenance {{flags}}"

# ═══════════════════════════════════════════════════════════
# DEVELOPMENT WORKFLOWS (Plan → Build → Review → Fix)
# ═══════════════════════════════════════════════════════════

# Plan a feature — outputs to .claude/specs/
plan-feature prompt:
    claude --model {{model}} "/plan {{prompt}}"

# Build from a plan file — executes top-to-bottom
build plan_path:
    claude --model {{model}} "/build {{plan_path}}"

# Review completed work — risk-tiered validation report
review prompt plan_path="":
    claude --model {{model}} "/review {{prompt}} {{plan_path}}"

# Fix issues from a review report
fix review_path:
    claude --model {{model}} "/fix {{review_path}}"

# Full PITER cycle: Plan → Implement → Test → Evaluate → Refine
piter prompt:
    #!/usr/bin/env bash
    set -euo pipefail
    echo "=== PITER Cycle: {{prompt}} ==="
    echo ""
    echo "[P] Planning..."
    claude --model {{model}} --output-format json "/plan {{prompt}}" | tail -1
    echo ""
    # Find the latest plan
    plan=$(ls -t {{specs_dir}}/*.md 2>/dev/null | head -1)
    if [ -z "$plan" ]; then
        echo "No plan file found in {{specs_dir}}"
        exit 1
    fi
    echo "[I] Implementing from $plan..."
    claude --model {{model}} "/build $plan"
    echo ""
    echo "[T+E] Testing & Evaluating..."
    claude --model {{model}} "/review 'Validate implementation of: {{prompt}}' $plan"
    echo ""
    review=$(ls -t review_reports/*.md 2>/dev/null | head -1)
    if [ -n "$review" ]; then
        echo "[R] Refining from $review..."
        claude --model {{model}} "/fix $review"
    fi
    echo ""
    echo "=== PITER Complete ==="

# R&D cycle: Research → Develop (for exploration and bugs)
research-develop prompt:
    #!/usr/bin/env bash
    set -euo pipefail
    echo "=== R&D Cycle: {{prompt}} ==="
    echo ""
    echo "[R] Researching..."
    claude --model {{model}} "Research this thoroughly. Read all relevant files, search the codebase, and provide a detailed analysis: {{prompt}}"
    echo ""
    echo "[D] Developing..."
    claude --model {{model}} "Based on the research above, implement the solution: {{prompt}}"

# ═══════════════════════════════════════════════════════════
# SSVA PIPELINE (Specialized Self-Validating Agents)
# ═══════════════════════════════════════════════════════════

# Run a single SSVA agent — isolated context, scoped hooks
run-agent agent_name prompt:
    claude --model {{model}} "Use @{{agent_name}} to: {{prompt}}"

# Run parallel SSVA agents (comma-separated names)
run-agents-parallel agents prompt:
    #!/usr/bin/env bash
    set -euo pipefail
    IFS=',' read -ra AGENTS <<< "{{agents}}"
    pids=()
    for agent in "${AGENTS[@]}"; do
        agent=$(echo "$agent" | tr -d ' ')
        echo "Launching @$agent..."
        claude --model {{model}} "Use @$agent to: {{prompt}}" &
        pids+=($!)
    done
    echo "Waiting for ${#pids[@]} agents..."
    for pid in "${pids[@]}"; do
        wait "$pid" || echo "Agent PID $pid failed"
    done
    echo "All agents complete."

# Sequential pipeline — fail-fast if any agent blocks
pipeline *steps:
    #!/usr/bin/env bash
    set -euo pipefail
    step_num=1
    for step in {{steps}}; do
        echo "[$step_num] Running: $step"
        if ! claude --model {{model}} "$step"; then
            echo "PIPELINE HALTED at step $step_num: $step"
            exit 1
        fi
        step_num=$((step_num + 1))
    done
    echo "Pipeline complete: $((step_num - 1)) steps executed."

# ═══════════════════════════════════════════════════════════
# ADW OPERATIONS (Agentic Development Workflows)
# ═══════════════════════════════════════════════════════════

# Create an ADW document from template
create-adw name domain pattern="plan_build_review":
    #!/usr/bin/env bash
    set -euo pipefail
    output="{{specs_dir}}/{{ts}}-adw-{{name}}.md"
    sed -e "s/{{{{title}}}}/{{name}}/g" \
        -e "s/{{{{DATE}}}}/{{date}}/g" \
        -e "s/{{{{domain}}}}/{{domain}}/g" \
        -e "s/plan_build_review/{{pattern}}/g" \
        "{{plugin_dir}}/templates/adw-template.md" > "$output"
    echo "ADW created: $output"
    echo "Pattern: {{pattern}}"
    echo "Edit the file to add agents, I/O schemas, and triggers."

# Create a spec document from template
create-spec name:
    #!/usr/bin/env bash
    set -euo pipefail
    output="{{specs_dir}}/{{ts}}-{{name}}.md"
    cp "{{plugin_dir}}/templates/spec-template.md" "$output"
    echo "Spec created: $output"
    echo "Fill in the sections and run: just build $output"

# List all specs
list-specs:
    #!/usr/bin/env bash
    set -euo pipefail
    echo "Specs in {{specs_dir}}:"
    echo "═══════════════════════"
    if [ -d "{{specs_dir}}" ]; then
        ls -1t "{{specs_dir}}/"*.md 2>/dev/null | while read f; do
            name=$(basename "$f")
            lines=$(wc -l < "$f" | tr -d ' ')
            printf "  %-55s  %4s lines\n" "$name" "$lines"
        done
    else
        echo "  No specs directory found"
    fi

# ═══════════════════════════════════════════════════════════
# DOCUMENTATION & REFERENCE
# ═══════════════════════════════════════════════════════════

# Show the 8 TAC tactics quick reference
tactics:
    #!/usr/bin/env bash
    echo "The 8 TAC Tactics (S.A.T.S.F.O.Z.P)"
    echo "═════════════════════════════════════"
    echo ""
    echo "  1. Stop Coding           Don't type code, type instructions"
    echo "  2. Adopt Perspective     Think like the agent, design for its constraints"
    echo "  3. Template Engineering  Encode patterns in reusable templates"
    echo "  4. Stay Out of the Loop  Let the agent work without interruption"
    echo "  5. Feedback Loops        Build validation into every workflow"
    echo "  6. One Agent, One Prompt One focused prompt per agent"
    echo "  7. Zero-Touch            Automate from commit to deploy"
    echo "  8. Prioritize Agentics   Always choose the more agentic option"
    echo ""
    echo "Memory aid: S.A.T.S.F.O.Z.P"
    echo "  'SATS FO ZeP' — like a satellite launching toward zero-touch"

# Show the core frameworks reference
frameworks:
    #!/usr/bin/env bash
    echo "TAC Core Frameworks"
    echo "════════════════════"
    echo ""
    echo "  ACT-LEARN-REUSE    Do → Capture → Apply          Every task (default)"
    echo "  PITER              Plan → Implement → Test →      New features"
    echo "                     Evaluate → Refine"
    echo "  R&D                Research → Develop              Exploration, bugs"
    echo "  Core Four          CLAUDE.md + commands/ +         Project setup"
    echo "                     experts/ + settings.json"
    echo ""
    echo "Selection guide:"
    echo "  New feature?        → PITER"
    echo "  Investigating?      → R&D"
    echo "  Routine task?       → ACT-LEARN-REUSE"
    echo "  New project?        → Core Four + just bootstrap"

# Show the maturity model
maturity:
    #!/usr/bin/env bash
    echo "TAC Maturity Model"
    echo "═══════════════════"
    echo ""
    echo "  In-Loop     →  Human directs every step"
    echo "  Out-Loop    →  Agent completes, human reviews"
    echo "  Zero-Touch  →  Fully automated, human notified"
    echo ""
    echo "Graduation path:"
    echo "  In-Loop (3+ successes) → Template as command"
    echo "  → Add validation hooks → Out-Loop ADW"
    echo "  → CI/CD integration → Zero-Touch"
    echo ""
    echo "Anti-patterns:"
    echo "  - Skipping In-Loop (no pattern yet)"
    echo "  - Out-Loop without validation (no feedback)"
    echo "  - Zero-Touch without monitoring (no safety net)"

# Show the ecosystem layer reference
ecosystem:
    #!/usr/bin/env bash
    echo "Claude Code Ecosystem Layers"
    echo "═════════════════════════════"
    echo ""
    echo "Class 1 — Foundation"
    echo "  CLAUDE.md       Project identity, constraints, patterns"
    echo "  settings.json   Permissions, hooks, tool restrictions"
    echo ""
    echo "Class 2 — Out-Loop"
    echo "  commands/       Slash commands (/plan, /build, /review)"
    echo "  agents/         Subagent definitions (.md frontmatter)"
    echo "  experts/        Domain experts (7-file pattern)"
    echo ""
    echo "Class 3 — Orchestration"
    echo "  ADWs            Multi-step workflows (plan_build_review)"
    echo "  hooks/          Event handlers (PreToolUse, PostToolUse, Stop)"
    echo "  skills/         Packaged capabilities"
    echo "  justfile        Layer 4 reusability + composition"

# Show the SSVA pattern reference
ssva:
    #!/usr/bin/env bash
    echo "SSVA Pattern — Specialized Self-Validating Agents"
    echo "═══════════════════════════════════════════════════"
    echo ""
    echo "  Focused Agent + Specialized Validation = Trusted Automation"
    echo ""
    echo "Each SSVA agent:"
    echo "  1. Has ONE purpose         (Tactic 6: One Agent, One Prompt)"
    echo "  2. Has SCOPED hooks        (frontmatter, not global)"
    echo "  3. Can SELF-CORRECT        (block reason → next correction task)"
    echo "  4. Runs in ISOLATED context (agent vs command)"
    echo ""
    echo "Block/Retry Loop:"
    echo '  Hook output:  {"decision": "block", "reason": "Missing column: date"}'
    echo "  The reason string becomes Claude's next correction task."
    echo ""
    echo "Exit codes:"
    echo "  0  → Pass (proceed)"
    echo "  2  → Block (stderr fed back to Claude)"
    echo "  *  → Non-blocking warning"

# Show hook architecture quick reference
hooks:
    #!/usr/bin/env bash
    echo "Hook Architecture Quick Reference"
    echo "══════════════════════════════════"
    echo ""
    echo "Events:"
    echo "  PreToolUse     Before tool call    Security guards, path restrictions"
    echo "  PostToolUse    After tool call     Per-operation validation"
    echo "  Stop           Agent completes     Final-state validation, pipeline gating"
    echo "  SessionStart   Session begins      Context injection, state loading"
    echo ""
    echo "Scoping:"
    echo "  Global         settings.json       All sessions"
    echo "  Per-command    YAML frontmatter    Only that command/agent"
    echo ""
    echo "Cost tradeoff:"
    echo "  PostToolUse    Fires every operation  (expensive but immediate)"
    echo "  Stop           Fires once at end      (cheap but late)"
    echo ""
    echo "Validator protocol: exit 0=pass, exit 2=block, other=warn"

# Show the validation ladder
validation-ladder:
    #!/usr/bin/env bash
    echo "Validation Ladder (TAC #5: Feedback Loops)"
    echo "════════════════════════════════════════════"
    echo ""
    echo "  Level 1 — Lint        ruff check (Python) / tsc --noEmit (TypeScript)"
    echo "  Level 2 — Unit        pytest (backend) / vitest (frontend)"
    echo "  Level 3 — E2E         playwright test (frontend flows)"
    echo "  Level 4 — Infra       cdk synth --quiet (CDK compiles)"
    echo "  Level 5 — Integration docker compose up --build (full stack)"
    echo "  Level 6 — Eval        CloudWatch post-deploy metrics"
    echo ""
    echo "Minimum levels by change type:"
    echo "  Typo / copy fix     → Level 1"
    echo "  Backend logic       → Level 1 + 2"
    echo "  Frontend UI         → Level 1 + 3"
    echo "  CDK change          → Level 1 + 4"
    echo "  Cross-stack feature → Level 1-5"
    echo "  Production deploy   → Level 1-6"

# Show the progressive execution modes reference
progressive-modes:
    #!/usr/bin/env bash
    echo "Progressive Execution Modes"
    echo "═══════════════════════════"
    echo ""
    echo "  DETERMINISTIC        AGENTIC              INTERACTIVE"
    echo "  (hooks only)         (hook + prompt)      (hook + questions)"
    echo "  ──────────────       ──────────────       ────────────────"
    echo "  claude --init        claude --init        claude --init"
    echo "                       \"/install\"           \"/install true\""
    echo ""
    echo "  Fast                 Supervised           Asks Questions"
    echo "  Predictable          Diagnostic           Adapts"
    echo "  CI-friendly          Reports              Context-aware"
    echo ""
    echo "Pattern: Hook → Log → Prompt → Report"
    echo "  1. Hook runs deterministic script (source of truth)"
    echo "  2. Script writes to log file (append mode)"
    echo "  3. Agentic prompt reads log and analyzes"
    echo "  4. Agent reports status, issues, next steps"
    echo ""
    echo "The script is the source of truth."
    echo "The agent provides supervision and context-aware guidance."
    echo "Result: Living documentation that actually executes."
    echo ""
    echo "Justfile recipes:"
    echo "  just init                Deterministic"
    echo "  just init-agentic        Agentic"
    echo "  just init-interactive    Interactive"
    echo "  just maintain            Deterministic"
    echo "  just maintain-agentic    Agentic"
    echo ""
    echo "Setup hook config (settings.json):"
    echo '  "Setup": [{"matcher": "init", ...}, {"matcher": "maintenance", ...}]'

# Read a specific TAC doc
read-doc doc:
    #!/usr/bin/env bash
    set -euo pipefail
    target="{{plugin_dir}}/docs/{{doc}}.md"
    if [ -f "$target" ]; then
        cat "$target"
    else
        echo "Doc not found: {{doc}}"
        echo "Available docs:"
        ls -1 "{{plugin_dir}}/docs/" | sed 's/\.md$//' | sed 's/^/  /'
    fi

# List all available docs
list-docs:
    #!/usr/bin/env bash
    echo "TAC Documentation"
    echo "══════════════════"
    for f in "{{plugin_dir}}/docs/"*.md; do
        name=$(basename "$f" .md)
        lines=$(wc -l < "$f" | tr -d ' ')
        # Extract first heading as description
        desc=$(head -5 "$f" | grep "^>" | head -1 | sed 's/^> //' | head -c 60)
        printf "  %-25s  %4s lines  %s\n" "$name" "$lines" "$desc"
    done
    echo ""
    echo "Read a doc: just read-doc <name>"

# Search across all plugin docs
search-docs query:
    #!/usr/bin/env bash
    echo "Searching plugin docs for: {{query}}"
    echo "═══════════════════════════════════════"
    grep -rn -i "{{query}}" "{{plugin_dir}}/docs/" --include="*.md" | head -30 || echo "No matches found"

# Search across all plugin files
search-all query:
    #!/usr/bin/env bash
    echo "Searching all plugin files for: {{query}}"
    echo "═══════════════════════════════════════════"
    grep -rn -i "{{query}}" "{{plugin_dir}}/" --include="*.md" --include="*.json" | head -50 || echo "No matches found"

# ═══════════════════════════════════════════════════════════
# TEMPLATE OPERATIONS
# ═══════════════════════════════════════════════════════════

# List all available templates
list-templates:
    #!/usr/bin/env bash
    echo "Available Templates"
    echo "════════════════════"
    echo ""
    echo "Expert Template (7 files):"
    for f in "{{plugin_dir}}/templates/expert/"*; do
        printf "  %s\n" "$(basename $f)"
    done
    echo ""
    echo "CLAUDE.md Templates:"
    for f in "{{plugin_dir}}/templates/claude-md/"*; do
        name=$(basename "$f" .md)
        printf "  %s\n" "$name"
    done
    echo ""
    echo "Other Templates:"
    echo "  adw-template.md       Agentic Development Workflow"
    echo "  spec-template.md      Implementation specification"
    echo ""
    echo "Usage:"
    echo "  just scaffold-expert <domain> <title> <description>"
    echo "  just install-claude-md"
    echo "  just create-adw <name> <domain>"
    echo "  just create-spec <name>"

# Show placeholders in expert template
show-placeholders:
    #!/usr/bin/env bash
    echo "Expert Template Placeholders"
    echo "═════════════════════════════"
    echo ""
    echo "  {{DOMAIN}}         → Expert domain slug (kebab-case)"
    echo "  {{DOMAIN_TITLE}}   → Expert display name"
    echo "  {{DESCRIPTION}}    → One-line description"
    echo "  {{DATE}}           → ISO timestamp"
    echo "  {{AREA_1}}         → First scope area name"
    echo "  {{AREA_1_DESC}}    → First scope area description"
    echo "  {{AREA_2}}         → Second scope area name"
    echo "  {{AREA_2_DESC}}    → Second scope area description"
    echo "  {{AREA_3}}         → Third scope area name"
    echo "  {{AREA_3_DESC}}    → Third scope area description"
    echo ""
    echo "just scaffold-expert fills DOMAIN, DOMAIN_TITLE, DESCRIPTION, DATE"
    echo "You fill the AREA placeholders manually after scaffolding."

# Copy an example command to your project's commands directory
install-command name:
    #!/usr/bin/env bash
    set -euo pipefail
    src="{{plugin_dir}}/examples/commands/{{name}}.md"
    if [ ! -f "$src" ]; then
        echo "Example command not found: {{name}}"
        echo "Available: plan, build, review, fix"
        exit 1
    fi
    mkdir -p "{{commands_dir}}"
    cp "$src" "{{commands_dir}}/{{name}}.md"
    echo "Command installed: {{commands_dir}}/{{name}}.md"
    echo "Usage: /{{name}} <args>"

# Copy an example agent to your project's agents directory
install-agent name:
    #!/usr/bin/env bash
    set -euo pipefail
    src="{{plugin_dir}}/examples/agents/{{name}}.md"
    if [ ! -f "$src" ]; then
        echo "Example agent not found: {{name}}"
        echo "Available: hooks-expert-agent, bowser-qa-agent"
        exit 1
    fi
    mkdir -p "{{agents_dir}}"
    cp "$src" "{{agents_dir}}/{{name}}.md"
    echo "Agent installed: {{agents_dir}}/{{name}}.md"
    echo "Usage: 'Use @{{name}} to...'"

# Install all example commands and agents
install-examples:
    #!/usr/bin/env bash
    set -euo pipefail
    echo "Installing example commands..."
    for f in "{{plugin_dir}}/examples/commands/"*.md; do
        name=$(basename "$f" .md)
        just install-command "$name"
    done
    echo ""
    echo "Installing example agents..."
    for f in "{{plugin_dir}}/examples/agents/"*.md; do
        name=$(basename "$f" .md)
        just install-agent "$name"
    done
    echo ""
    echo "All examples installed."

# ═══════════════════════════════════════════════════════════
# PLUGIN HEALTH & MANAGEMENT
# ═══════════════════════════════════════════════════════════

# Show plugin info
info:
    #!/usr/bin/env bash
    set -euo pipefail
    echo "TAC Experts Plugin"
    echo "═══════════════════"
    cat "{{plugin_dir}}/plugin.json" | python3 -c "
import json, sys
d = json.load(sys.stdin)
print(f\"  Name:     {d['name']}\")
print(f\"  Version:  {d['version']}\")
print(f\"  Author:   {d['author']}\")
print(f\"  Commands: {len(d.get('commands', {}))}\")
print(f\"  Docs:     {len(d.get('provides', {}).get('docs', []))}\")
print(f\"  Templates: {len(d.get('provides', {}).get('templates', []))}\")
" 2>/dev/null || cat "{{plugin_dir}}/plugin.json"

# Count all files and lines in the plugin
stats:
    #!/usr/bin/env bash
    set -euo pipefail
    echo "Plugin Statistics"
    echo "══════════════════"
    total_files=0
    total_lines=0
    for section in commands templates docs examples data; do
        dir="{{plugin_dir}}/$section"
        if [ -d "$dir" ]; then
            files=$(find "$dir" -type f | wc -l | tr -d ' ')
            lines=$(find "$dir" -type f -exec cat {} + 2>/dev/null | wc -l | tr -d ' ')
            printf "  %-12s  %3s files  %5s lines\n" "$section/" "$files" "$lines"
            total_files=$((total_files + files))
            total_lines=$((total_lines + lines))
        fi
    done
    # Root files
    root_files=$(ls -1 "{{plugin_dir}}"/*.{json,md} 2>/dev/null | wc -l | tr -d ' ')
    root_lines=$(cat "{{plugin_dir}}"/*.{json,md} 2>/dev/null | wc -l | tr -d ' ')
    printf "  %-12s  %3s files  %5s lines\n" "root" "$root_files" "$root_lines"
    total_files=$((total_files + root_files))
    total_lines=$((total_lines + root_lines))
    # Justfile
    if [ -f "{{plugin_dir}}/justfile" ]; then
        jf_lines=$(wc -l < "{{plugin_dir}}/justfile" | tr -d ' ')
        printf "  %-12s  %3s files  %5s lines\n" "justfile" "1" "$jf_lines"
        total_files=$((total_files + 1))
        total_lines=$((total_lines + jf_lines))
    fi
    echo "  ────────────────────────────────"
    printf "  %-12s  %3s files  %5s lines\n" "TOTAL" "$total_files" "$total_lines"

# Validate plugin structure — check all expected files exist
validate-plugin:
    #!/usr/bin/env bash
    set -euo pipefail
    echo "Plugin Structure Validation"
    echo "═══════════════════════════"
    ok=0
    fail=0
    check() {
        if [ -e "{{plugin_dir}}/$1" ]; then
            printf "  [OK]   %s\n" "$1"
            ok=$((ok + 1))
        else
            printf "  [MISS] %s\n" "$1"
            fail=$((fail + 1))
        fi
    }
    # Root
    check "plugin.json"
    check "README.md"
    check "justfile"
    # TAC Expert (7 files)
    for f in _index.md expertise.md question.md plan.md plan_build_improve.md self-improve.md maintenance.md; do
        check "commands/experts/tac/$f"
    done
    # Templates
    for f in _index.md expertise.md question.md plan.md plan_build_improve.md self-improve.md maintenance.md; do
        check "templates/expert/$f"
    done
    check "templates/claude-md/option-a-enterprise.md"
    check "templates/claude-md/option-b-mission-control.md"
    check "templates/claude-md/option-c-fullstack-blueprint.md"
    check "templates/adw-template.md"
    check "templates/spec-template.md"
    # Docs (9)
    for doc in tactics advanced-lessons adw-patterns frameworks hooks-architecture context-engineering maturity-model ecosystem agentic-prompting; do
        check "docs/$doc.md"
    done
    # Example Commands
    for cmd in plan build review fix install install-hil maintenance-agentic prime; do
        check "examples/commands/$cmd.md"
    done
    # Example Agents
    check "examples/agents/hooks-expert-agent.md"
    check "examples/agents/bowser-qa-agent.md"
    check "examples/agents/docs-scraper.md"
    # Example Hooks
    check "examples/hooks/session_start.py"
    check "examples/hooks/setup_init.py"
    check "examples/hooks/setup_maintenance.py"
    # Other Examples
    check "examples/experts/README.md"
    check "examples/justfile"
    check "examples/agentic-prompting-justfile"
    # Data
    check "data/frontmatter-schemas.md"
    echo ""
    echo "Results: $ok present, $fail missing"
    [ "$fail" -eq 0 ] && echo "Status: PASS" || echo "Status: FAIL"
    [ "$fail" -eq 0 ] || exit 1

# Show the full directory tree
tree:
    #!/usr/bin/env bash
    if command -v tree &> /dev/null; then
        tree "{{plugin_dir}}" --charset=utf-8 -I '__pycache__|node_modules|.git'
    else
        find "{{plugin_dir}}" -type f | sort | sed "s|{{plugin_dir}}/||" | sed 's/^/  /'
    fi

# ═══════════════════════════════════════════════════════════
# EXPERTISE MANAGEMENT
# ═══════════════════════════════════════════════════════════

# Show expertise line counts for all experts
expertise-status:
    #!/usr/bin/env bash
    echo "Expertise File Status"
    echo "═════════════════════"
    max=1500
    if [ -d "{{experts_dir}}" ]; then
        for dir in "{{experts_dir}}"/*/; do
            domain=$(basename "$dir")
            exp="$dir/expertise.md"
            if [ -f "$exp" ]; then
                lines=$(wc -l < "$exp" | tr -d ' ')
                pct=$((lines * 100 / max))
                bar=""
                for i in $(seq 1 $((pct / 5))); do bar="${bar}#"; done
                printf "  %-18s  %4s/%s lines  [%-20s] %s%%\n" "$domain" "$lines" "$max" "$bar" "$pct"
            else
                printf "  %-18s  no expertise.md\n" "$domain"
            fi
        done
    fi
    # Plugin TAC expertise
    plugin_exp="{{plugin_dir}}/commands/experts/tac/expertise.md"
    if [ -f "$plugin_exp" ]; then
        lines=$(wc -l < "$plugin_exp" | tr -d ' ')
        pct=$((lines * 100 / max))
        printf "\n  %-18s  %4s/%s lines  (plugin copy)\n" "tac (plugin)" "$lines" "$max"
    fi

# Sync plugin TAC expertise back to project (plugin → project)
sync-expertise-to-project:
    #!/usr/bin/env bash
    set -euo pipefail
    src="{{plugin_dir}}/commands/experts/tac/expertise.md"
    dst="{{experts_dir}}/tac/expertise.md"
    if [ ! -f "$src" ]; then
        echo "Plugin expertise not found: $src"
        exit 1
    fi
    if [ ! -d "$(dirname $dst)" ]; then
        echo "Project TAC expert not found. Run: just install"
        exit 1
    fi
    cp "$src" "$dst"
    echo "Synced: plugin → project"
    echo "  $src → $dst"

# Sync project TAC expertise back to plugin (project → plugin)
sync-expertise-to-plugin:
    #!/usr/bin/env bash
    set -euo pipefail
    src="{{experts_dir}}/tac/expertise.md"
    dst="{{plugin_dir}}/commands/experts/tac/expertise.md"
    if [ ! -f "$src" ]; then
        echo "Project TAC expertise not found: $src"
        exit 1
    fi
    cp "$src" "$dst"
    echo "Synced: project → plugin"
    echo "  $src → $dst"

# Diff plugin vs project TAC expertise
diff-expertise:
    #!/usr/bin/env bash
    src="{{plugin_dir}}/commands/experts/tac/expertise.md"
    dst="{{experts_dir}}/tac/expertise.md"
    if [ -f "$src" ] && [ -f "$dst" ]; then
        diff --color "$src" "$dst" || true
    else
        echo "Cannot diff: one or both files missing"
        [ -f "$src" ] || echo "  Missing: $src"
        [ -f "$dst" ] || echo "  Missing: $dst"
    fi

# ═══════════════════════════════════════════════════════════
# CONTEXT ENGINEERING
# ═══════════════════════════════════════════════════════════

# Check CLAUDE.md line count (should be < 200 for production)
check-claude-md target_project=project_dir:
    #!/usr/bin/env bash
    f="{{target_project}}/CLAUDE.md"
    if [ -f "$f" ]; then
        lines=$(wc -l < "$f" | tr -d ' ')
        echo "CLAUDE.md: $lines lines"
        if [ "$lines" -gt 200 ]; then
            echo "WARNING: Exceeds 200-line production limit"
            echo "Consider moving detailed sections to experts or docs/"
        else
            echo "OK: Within 200-line limit"
        fi
    else
        echo "No CLAUDE.md found at $f"
    fi

# Prime a session — load full project context
prime:
    claude --model {{model}} "/prime"

# ═══════════════════════════════════════════════════════════
# FRONTMATTER & SCHEMA VALIDATION
# ═══════════════════════════════════════════════════════════

# Validate YAML frontmatter in a markdown file
validate-frontmatter file:
    #!/usr/bin/env bash
    set -euo pipefail
    if [ ! -f "{{file}}" ]; then
        echo "File not found: {{file}}"
        exit 1
    fi
    # Check if file starts with ---
    first_line=$(head -1 "{{file}}")
    if [ "$first_line" != "---" ]; then
        echo "No YAML frontmatter found in {{file}}"
        exit 1
    fi
    # Extract frontmatter
    fm=$(sed -n '/^---$/,/^---$/p' "{{file}}" | head -n -1 | tail -n +2)
    echo "Frontmatter in {{file}}:"
    echo "$fm"
    echo ""
    # Check for required fields based on file location
    if echo "{{file}}" | grep -q "_index.md"; then
        for field in type domain tags; do
            if echo "$fm" | grep -q "^$field:"; then
                echo "  [OK] $field"
            else
                echo "  [MISS] $field"
            fi
        done
    elif echo "{{file}}" | grep -q "expertise.md"; then
        for field in type domain version; do
            if echo "$fm" | grep -q "^$field:"; then
                echo "  [OK] $field"
            else
                echo "  [MISS] $field"
            fi
        done
    fi

# Validate frontmatter across all experts
validate-all-frontmatter:
    #!/usr/bin/env bash
    set -euo pipefail
    echo "Frontmatter Validation"
    echo "══════════════════════"
    if [ -d "{{experts_dir}}" ]; then
        for dir in "{{experts_dir}}"/*/; do
            domain=$(basename "$dir")
            echo ""
            echo "[$domain]"
            for f in "$dir"*.md; do
                [ -f "$f" ] || continue
                name=$(basename "$f")
                first=$(head -1 "$f" 2>/dev/null)
                if [ "$first" = "---" ]; then
                    printf "  %-25s  has frontmatter\n" "$name"
                else
                    printf "  %-25s  NO frontmatter\n" "$name"
                fi
            done
        done
    fi

# ═══════════════════════════════════════════════════════════
# COMPOSITION RECIPES (Layer 4 — named workflows)
# ═══════════════════════════════════════════════════════════

# Full expert setup — scaffold + seed + self-improve
setup-expert domain domain_title description source="":
    #!/usr/bin/env bash
    set -euo pipefail
    echo "=== Full Expert Setup: {{domain}} ==="
    echo ""
    just scaffold-expert "{{domain}}" "{{domain_title}}" "{{description}}"
    echo ""
    if [ -n "{{source}}" ]; then
        echo "Seeding expertise from {{source}}..."
        just self-improve "{{domain}}" "{{source}}"
    fi
    echo ""
    just validate-expert "{{domain}}"
    echo ""
    echo "Expert {{domain}} is ready. Try:"
    echo "  just question {{domain}} 'How does X work?'"

# Weekly maintenance — validate all experts + check CLAUDE.md
weekly-maintenance:
    #!/usr/bin/env bash
    set -euo pipefail
    echo "=== Weekly TAC Maintenance ==="
    echo ""
    echo "[1/4] Validating plugin structure..."
    just validate-plugin
    echo ""
    echo "[2/4] Validating all experts..."
    just validate-all-experts
    echo ""
    echo "[3/4] Checking expertise line counts..."
    just expertise-status
    echo ""
    echo "[4/4] Checking CLAUDE.md..."
    just check-claude-md
    echo ""
    echo "=== Maintenance Complete ==="

# Full self-improve cycle — update all experts
self-improve-all:
    #!/usr/bin/env bash
    set -euo pipefail
    echo "=== Self-Improve All Experts ==="
    if [ -d "{{experts_dir}}" ]; then
        for dir in "{{experts_dir}}"/*/; do
            domain=$(basename "$dir")
            echo ""
            echo "--- Self-improving: $domain ---"
            just self-improve "$domain" || echo "  (skipped — no self-improve source)"
        done
    fi
    echo ""
    echo "=== All experts updated ==="

# ═══════════════════════════════════════════════════════════
# CHEATSHEET
# ═══════════════════════════════════════════════════════════

# Print the full TAC cheatsheet
cheatsheet:
    #!/usr/bin/env bash
    echo "╔══════════════════════════════════════════════════════════════╗"
    echo "║              TAC EXPERTS PLUGIN — CHEATSHEET                ║"
    echo "╚══════════════════════════════════════════════════════════════╝"
    echo ""
    echo "SETUP & INSTALL"
    echo "  just bootstrap                    Full project setup"
    echo "  just install                      Install TAC expert only"
    echo "  just install-claude-md            Choose & install CLAUDE.md"
    echo "  just install-examples             Install all commands + agents"
    echo ""
    echo "PROGRESSIVE MODES (Deterministic → Agentic → Interactive)"
    echo "  just init                         Deterministic install (CI/CD)"
    echo "  just init-only                    Hook only, no session (fastest)"
    echo "  just init-agentic                 Hook + log analysis + report"
    echo "  just init-interactive             Hook + questions (onboarding)"
    echo "  just maintain                     Deterministic maintenance"
    echo "  just maintain-agentic             Hook + trend analysis + report"
    echo "  just reset                        Clean state for testing"
    echo "  just fresh                        Reset + deterministic install"
    echo "  just fresh-interactive            Reset + interactive install"
    echo "  just backend                      Run backend dev server (:8000)"
    echo "  just frontend                     Run frontend dev server (:5173)"
    echo "  just dev                          Run both servers"
    echo ""
    echo "EXPERTS"
    echo "  just scaffold-expert d t desc     Create new domain expert"
    echo "  just setup-expert d t desc src    Scaffold + seed + validate"
    echo "  just list-experts                 List all domain experts"
    echo "  just validate-expert <domain>     Check 7-file structure"
    echo "  just validate-all-experts         Check all experts"
    echo ""
    echo "TAC COMMANDS"
    echo "  just tac-question 'question'      Ask TAC methodology"
    echo "  just tac-plan 'prompt'            Plan with TAC principles"
    echo "  just tac-pbi 'prompt'             Full ACT-LEARN-REUSE"
    echo "  just tac-self-improve [source]    Update TAC knowledge"
    echo "  just tac-maintenance [flags]      Validate TAC compliance"
    echo ""
    echo "ANY EXPERT"
    echo "  just question <domain> 'q'        Ask any expert"
    echo "  just plan <domain> 'prompt'       Plan with any expert"
    echo "  just plan-build-improve d 'p'     Full cycle, any expert"
    echo "  just self-improve <domain> [src]  Update any expert"
    echo ""
    echo "DEV WORKFLOW"
    echo "  just plan-feature 'prompt'        Create a spec"
    echo "  just build <plan_path>            Build from spec"
    echo "  just review 'prompt' [plan]       Risk-tiered review"
    echo "  just fix <review_path>            Fix review issues"
    echo "  just piter 'prompt'               Full PITER cycle"
    echo "  just research-develop 'prompt'    R&D cycle"
    echo ""
    echo "SSVA & PIPELINES"
    echo "  just run-agent <name> 'prompt'    Run isolated agent"
    echo "  just run-agents-parallel a,b 'p'  Run agents in parallel"
    echo "  just pipeline 'step1' 'step2'     Sequential fail-fast"
    echo ""
    echo "DOCS & REFERENCE"
    echo "  just tactics                      8 TAC tactics"
    echo "  just frameworks                   Core frameworks"
    echo "  just maturity                     Maturity model"
    echo "  just ecosystem                    Ecosystem layers"
    echo "  just ssva                         SSVA pattern"
    echo "  just hooks                        Hook architecture"
    echo "  just validation-ladder            Validation levels"
    echo "  just list-docs                    All documentation"
    echo "  just read-doc <name>              Read a specific doc"
    echo "  just search-docs 'query'          Search docs"
    echo ""
    echo "MANAGEMENT"
    echo "  just info                         Plugin version + stats"
    echo "  just stats                        File & line counts"
    echo "  just validate-plugin              Check plugin structure"
    echo "  just weekly-maintenance           Full health check"
    echo "  just expertise-status             Expertise line counts"
    echo "  just diff-expertise               Plugin vs project diff"
    echo "  just sync-expertise-to-project    Plugin → project"
    echo "  just sync-expertise-to-plugin     Project → plugin"
